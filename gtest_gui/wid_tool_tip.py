#!/usr/bin/env python3

# ------------------------------------------------------------------------ #
# Copyright (C) 2023 Th. Zoerner
# ------------------------------------------------------------------------ #
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# ------------------------------------------------------------------------ #

"""
Implements the tool-tip widget class and a tool-tipped menu class.
"""

import re
import tkinter as tk

import gtest_gui.tk_utils as tk_utils
from gtest_gui.tool_tip_db import TOOL_TIP_DB


def enable_tips(enable):
    """
    Notifies about configuration change of the tool-tip enable flag.
    """
    ToolTipWidget.get_instance().enable_all(enable)


def tool_tip_add(wid, key):
    """
    Registers a given tool-tip help text for the given widget. The help text
    to be displayed is identified by a unique key into the tool tip database.
    Alternatively, a callable may be passed that returns a string to be
    displayed. The callable will be invoked each time the tool-tip is about to
    be displayed, so that the text can be updated.
    """
    ToolTipWidget.get_instance().add_tool_tip(wid, key)


# ---- below is private ----


class ToolTipWidget:
    """ Event handler class for all widgets with registered tool-tips """
    singleton = None

    @classmethod
    def get_instance(cls):
        """ Returns the singleton instance implemented by the class. """
        if ToolTipWidget.singleton is None:
            ToolTipWidget.singleton = ToolTipWidget()
        return ToolTipWidget.singleton


    def __init__(self):
        """
        Constructs a new instance. The instance will be inactive until
        tool-tips are added via method add_tool_tip().
        """
        self.__enable_tips = True
        self.__timer_id = None
        self.__wid_anchor = None
        self.__wid_tip = None
        self.__cur_msg = ""
        self.__under_construction = False


    def enable_all(self, enable):
        """
        Notifies about a configuration change of the tool-tip enable flag.
        """
        self.__enable_tips = enable


    def add_tool_tip(self, wid, key):
        """
        Registers a given tool-tip help text for the given widget. Registration
        is done by adding Motion and Leave events on the widget, which are used
        to detect when the mouse is hovering for a certain minimum time over
        the widget.
        """
        if callable(key):
            msg = key
        else:
            msg = re.sub(r"\n", " ", TOOL_TIP_DB[key].strip())

        wid.bind("<Leave>", lambda e: self.__handle_leave())
        wid.bind("<Motion>", lambda e: self.__handle_motion(wid, e.x, e.y, e.x_root, e.y_root, msg))


    def __handle_leave(self):
        """ Handler for Leave event on all tool-tipped widgets: Destroys the tool-tip. """
        if not self.__under_construction:
            self.__destroy_window()


    def __handle_motion(self, wid, wid_x, wid_y, wid_xroot, wid_yroot, msg):
        """
        Handler for Motion event on all tool-tipped widgets: Used for detecting the
        mouse entering a widget area and afterwards for detecting movements within
        the area.
        """
        if not self.__enable_tips:
            return

        if wid != self.__wid_anchor:
            self.__destroy_window()

        # Update tool-tip text, if currently displayed and texts are generated by callable.
        if self.__wid_tip:
            if callable(msg):
                if msg(wid_x, wid_y) != self.__cur_msg:
                    self.__destroy_window()
                    self.__handle_timer(wid, wid_x, wid_y, wid_xroot, wid_yroot, msg)

        else:
            # Mouse motion while tool-tip not yet shown: Start or restart delay timer
            if self.__timer_id:
                tk_utils.tk_top.after_cancel(self.__timer_id)

            self.__timer_id = \
                tk_utils.tk_top.after(1000, lambda: self.__handle_timer(wid, wid_x, wid_y,
                                                                        wid_xroot, wid_yroot, msg))
            self.__wid_anchor = wid


    def __handle_timer(self, wid, wid_x, wid_y, wid_xroot, wid_yroot, msg):
        """
        Handler for delay timer: Create the overlay widget and display the help text.
        """
        self.__timer_id = None
        self.__wid_anchor = wid

        if callable(msg):
            msg = msg(wid_x, wid_y)
            if not msg:
                return
            self.__cur_msg = msg

        self.__destroy_window()
        self.__create_window(msg)
        self.__map_window(wid_xroot, wid_yroot)


    def __create_window(self, msg):
        """
        Helper function for creating the widget showing the help text. Text is
        formatted automatically to 60 characters per line. Background is a light
        yellow as per common convetion for tool-tips.
        """
        self.__wid_tip = tk.Toplevel(tk_utils.tk_top)
        self.__wid_tip.wm_overrideredirect(1)
        self.__wid_tip.wm_withdraw()

        char_w = tk_utils.font_normal.measure("0")
        wid_lab = tk.Message(self.__wid_tip, borderwidth=1, relief=tk.SUNKEN, bg="#FFFFA0",
                             text=msg, font=tk_utils.font_normal, anchor=tk.W, justify=tk.LEFT,
                             width=60*char_w)
        wid_lab.pack()

        wid_lab.bind("<Leave>", lambda e: self.__handle_leave())


    def __map_window(self, coord_x, coord_y):
        """
        Helper function for placing the overlay window on the screen with its
        lower-left corner nead the mouse position, however so that it is not cut off
        at any screen border.
        """
        # Wait until the widget is constructed to allow querying its geometry
        self.__under_construction = True
        self.__wid_tip.update()

        # Window might have been destroyed while waiting
        if tk_utils.wid_exists(self.__wid_tip):
            coord_x += 10
            coord_y -= 10 + self.__wid_tip.winfo_reqheight()

            wid_w = self.__wid_tip.winfo_reqwidth()
            root_w = self.__wid_tip.winfo_screenwidth()
            if coord_x + wid_w > root_w:
                coord_x = root_w - wid_w
            if coord_x < 0:
                coord_x = 0

            wid_h = self.__wid_tip.winfo_reqheight()
            root_h = self.__wid_tip.winfo_screenheight()
            if coord_y + wid_h > root_h:
                coord_y = root_h - wid_h
            if coord_y < 0:
                coord_y = 0

            self.__wid_tip.wm_geometry("+%d+%d" % (coord_x, coord_y))
            self.__wid_tip.wm_deiconify()

        # Enable handler for leave event only after the widget is mapped
        if self.__wid_tip:
            self.__wid_tip.update()
        self.__under_construction = False


    def __destroy_window(self):
        """ Helper function for removing the tool-tip widget. """
        if self.__wid_tip:
            tk_utils.safe_destroy(self.__wid_tip)

        if self.__timer_id:
            tk_utils.tk_top.after_cancel(self.__timer_id)

        self.__timer_id = None
        self.__wid_tip = None


# ---- Wrapper class ----

class Menu(tk.Menu):  # pylint: disable=too-many-ancestors
    """
    This class can be used for creating a Tk menu widget with tool-tips for
    individual menu entries. The class overloads the "add" methods of class
    "Menu" so that an additional "tooltip" parameter can be specified for each
    entry. The parameter works equivalently to function tool_tip_add() on
    regular widgets.
    """
    def __init__(self, parent, **kwargs):
        self.tooltip = {}
        super().__init__(parent, **kwargs)
        tool_tip_add(self, self.__get_tool_tip)


    def __get_tool_tip(self, xcoo, ycoo):
        # abstract interface: unused parameter may be needed by other classes
        # pylint: disable=unused-argument
        idx = super().index("@" + str(ycoo))
        key = self.tooltip.get(idx, None)

        if not key:
            return ""

        if callable(key):
            return key()

        return re.sub(r"\n", " ", TOOL_TIP_DB[key].strip())


    def __install_tool_tip(self, kwargs, tooltip):
        if tooltip:
            idx = super().index(kwargs["label"])
            self.tooltip[idx] = tooltip

    def add_command(self, cnf=(), **kwargs):
        """ Overloads the like-named Menu command to add a "tooltip" parameter. """
        tooltip = kwargs.pop("tooltip", None)
        super().add_command(*cnf, **kwargs)
        self.__install_tool_tip(kwargs, tooltip)


    def add_checkbutton(self, cnf=(), **kwargs):
        """ Overloads the like-named Menu command to add a "tooltip" parameter. """
        tooltip = kwargs.pop("tooltip", None)
        super().add_checkbutton(*cnf, **kwargs)
        self.__install_tool_tip(kwargs, tooltip)


    def add_radiobutton(self, cnf=(), **kwargs):
        """ Overloads the like-named Menu command to add a "tooltip" parameter. """
        tooltip = kwargs.pop("tooltip", None)
        super().add_radiobutton(*cnf, **kwargs)
        self.__install_tool_tip(kwargs, tooltip)
